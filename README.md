# Практикум №1 (вариант 18)
###### Даны α и буква x. Найти максимальное k, такое что в L есть слова, начинающиеся с x<sup>k</sup>.  
____  
**Предупреждение:** ответом на первый тест из ТЗ (ab+c.aba.∗.bac.+.+∗ a) является 0, а не 2, т.к. в инфиксной нотации это *((ca+b)(ab)<sup>∗</sup>a + c(b+a))<sup>∗</sup>*
____
Далее под степенью k буквы понимаем конкатенацию с собой k раз. Считаем, что все три поля содержат информацию об обрататываемом регулярном выражении, т.е. таком, что "находится" на "верху" стека.  
  
Логика моего решения фактически вращается вокруг двух полей (информации в них) - `maxDeg`и `minLen`.  
  
`maxDeg` - наибольшая степень буквы x в префиксе рег. выражения. Равна -1, если степень бесконечна;  
`minLen` - длина наибольшего слова, которое состоит только из букв x, но если таких нет равна -2, если есть *1*. Например, в языках, задаваемых *ba + c*, *ba + c + 1*, *a + ba + c + 1*, `minLen` будет равно 0, -2 и 1 соответственно. Эта информация нужна для того, чтобы правильно обрабатывать случаи типа *(ab+1)aa* для буквы *a* (в левой скобке `maxDeg` равно 1, но `minLen` равно -2, т.к. нет слов, состоящих только из повторяющихся *a*, а в правой скобке степень выше, а значит конкатенацией *1* и *аа* можем получить бóльшую степень) или *b<sup>∗</sup>a* для *a*.  
P.S. Некоторые вещи, такие как std::min, std::max пришлось заменить на тернарный оператор ради увеличения процента Code Coverage.


